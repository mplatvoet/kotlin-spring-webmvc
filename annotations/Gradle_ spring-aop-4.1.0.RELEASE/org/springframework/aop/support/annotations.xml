<root>
    <item name='org.springframework.aop.support.ControlFlowPointcut org.springframework.aop.ClassFilter getClassFilter()'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.DefaultIntroductionAdvisor void addInterface(java.lang.Class&lt;?&gt;) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.Pointcuts org.springframework.aop.Pointcut intersection(org.springframework.aop.Pointcut, org.springframework.aop.Pointcut) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.AopUtils boolean canApply(org.springframework.aop.Pointcut, java.lang.Class&lt;?&gt;) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.NameMatchMethodPointcut boolean matches(java.lang.reflect.Method, java.lang.Class&lt;?&gt;) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
        <annotation name='org.jetbrains.kannotator.runtime.annotations.Propagated'>
            <val name="value" val="{org.jetbrains.kannotator.controlFlow.builder.analysis.NullabilityKey.class}"/>
        </annotation>
    </item>
    <item name='org.springframework.aop.support.AopUtils java.lang.Object invokeJoinpointUsingReflection(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) 1'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.ComposablePointcut org.springframework.aop.support.ComposablePointcut intersection(org.springframework.aop.ClassFilter)'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.StaticMethodMatcherPointcutAdvisor org.springframework.aop.Pointcut getPointcut()'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.Pointcuts org.springframework.aop.Pointcut intersection(org.springframework.aop.Pointcut, org.springframework.aop.Pointcut)'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.AbstractRegexpMethodPointcut void setPatterns(java.lang.String...) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.ComposablePointcut org.springframework.aop.support.ComposablePointcut union(org.springframework.aop.Pointcut) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.MethodMatchers org.springframework.aop.MethodMatcher union(org.springframework.aop.MethodMatcher, org.springframework.aop.MethodMatcher)'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.ComposablePointcut org.springframework.aop.support.ComposablePointcut union(org.springframework.aop.MethodMatcher)'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.ComposablePointcut org.springframework.aop.support.ComposablePointcut intersection(org.springframework.aop.MethodMatcher)'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.AbstractRegexpMethodPointcut void initPatternRepresentation(java.lang.String[]) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
        <annotation name='org.jetbrains.kannotator.runtime.annotations.Propagated'>
            <val name="value" val="{org.jetbrains.kannotator.controlFlow.builder.analysis.NullabilityKey.class}"/>
        </annotation>
    </item>
    <item name='org.springframework.aop.support.RegexpMethodPointcutAdvisor org.springframework.aop.support.AbstractRegexpMethodPointcut createPointcut()'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.ControlFlowPointcut boolean matches(java.lang.reflect.Method, java.lang.Class&lt;?&gt;) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
        <annotation name='org.jetbrains.kannotator.runtime.annotations.Propagated'>
            <val name="value" val="{org.jetbrains.kannotator.controlFlow.builder.analysis.NullabilityKey.class}"/>
        </annotation>
    </item>
    <item name='org.springframework.aop.support.DelegatingIntroductionInterceptor java.lang.Object doProceed(org.aopalliance.intercept.MethodInvocation) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.AopUtils java.util.List&lt;org.springframework.aop.Advisor&gt; findAdvisorsThatCanApply(java.util.List&lt;org.springframework.aop.Advisor&gt;, java.lang.Class&lt;?&gt;) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.Pointcuts org.springframework.aop.Pointcut union(org.springframework.aop.Pointcut, org.springframework.aop.Pointcut) 1'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.DelegatePerTargetObjectIntroductionInterceptor java.lang.Object doProceed(org.aopalliance.intercept.MethodInvocation) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.ClassFilters org.springframework.aop.ClassFilter union(org.springframework.aop.ClassFilter, org.springframework.aop.ClassFilter)'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.Pointcuts org.springframework.aop.Pointcut union(org.springframework.aop.Pointcut, org.springframework.aop.Pointcut)'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.AopUtils boolean canApply(org.springframework.aop.Pointcut, java.lang.Class&lt;?&gt;, boolean) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.AbstractRegexpMethodPointcut boolean matches(java.lang.reflect.Method, java.lang.Class&lt;?&gt;) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.MethodMatchers org.springframework.aop.MethodMatcher intersection(org.springframework.aop.MethodMatcher, org.springframework.aop.MethodMatcher)'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.DefaultIntroductionAdvisor org.springframework.aop.ClassFilter getClassFilter()'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.DynamicMethodMatcherPointcut org.springframework.aop.MethodMatcher getMethodMatcher()'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.JdkRegexpMethodPointcut void initExcludedPatternRepresentation(java.lang.String[]) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.Pointcuts org.springframework.aop.Pointcut union(org.springframework.aop.Pointcut, org.springframework.aop.Pointcut) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.ClassFilters org.springframework.aop.ClassFilter intersection(org.springframework.aop.ClassFilter, org.springframework.aop.ClassFilter)'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.ClassFilters org.springframework.aop.ClassFilter union(org.springframework.aop.ClassFilter[])'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.NameMatchMethodPointcutAdvisor org.springframework.aop.support.NameMatchMethodPointcut addMethodName(java.lang.String)'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.JdkRegexpMethodPointcut void initPatternRepresentation(java.lang.String[]) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.DefaultIntroductionAdvisor DefaultIntroductionAdvisor(org.springframework.aop.DynamicIntroductionAdvice, java.lang.Class&lt;?&gt;) 1'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.DynamicMethodMatcherPointcut org.springframework.aop.ClassFilter getClassFilter()'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.AbstractRegexpMethodPointcut void setExcludedPatterns(java.lang.String...) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.ClassFilters org.springframework.aop.ClassFilter intersection(org.springframework.aop.ClassFilter[])'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.ComposablePointcut org.springframework.aop.support.ComposablePointcut union(org.springframework.aop.Pointcut)'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.DelegatingIntroductionInterceptor java.lang.Object invoke(org.aopalliance.intercept.MethodInvocation) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.NameMatchMethodPointcutAdvisor org.springframework.aop.Pointcut getPointcut()'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.ComposablePointcut org.springframework.aop.support.ComposablePointcut union(org.springframework.aop.ClassFilter)'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.IntroductionInfoSupport publishedInterfaces'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.ComposablePointcut org.springframework.aop.support.ComposablePointcut intersection(org.springframework.aop.Pointcut)'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.MethodMatchers boolean matches(org.springframework.aop.MethodMatcher, java.lang.reflect.Method, java.lang.Class&lt;?&gt;, boolean) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.NameMatchMethodPointcut org.springframework.aop.support.NameMatchMethodPointcut addMethodName(java.lang.String)'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.ComposablePointcut org.springframework.aop.support.ComposablePointcut intersection(org.springframework.aop.Pointcut) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.ComposablePointcut ComposablePointcut(org.springframework.aop.Pointcut) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.AopUtils java.util.List&lt;org.springframework.aop.Advisor&gt; findAdvisorsThatCanApply(java.util.List&lt;org.springframework.aop.Advisor&gt;, java.lang.Class&lt;?&gt;)'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.IntroductionInfoSupport boolean isMethodOnIntroducedInterface(org.aopalliance.intercept.MethodInvocation) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.StaticMethodMatcherPointcut org.springframework.aop.MethodMatcher getMethodMatcher()'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.Pointcuts org.springframework.aop.Pointcut intersection(org.springframework.aop.Pointcut, org.springframework.aop.Pointcut) 1'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.ControlFlowPointcut org.springframework.aop.MethodMatcher getMethodMatcher()'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
    <item name='org.springframework.aop.support.AbstractRegexpMethodPointcut void initExcludedPatternRepresentation(java.lang.String[]) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
        <annotation name='org.jetbrains.kannotator.runtime.annotations.Propagated'>
            <val name="value" val="{org.jetbrains.kannotator.controlFlow.builder.analysis.NullabilityKey.class}"/>
        </annotation>
    </item>
    <item name='org.springframework.aop.support.DynamicMethodMatcher boolean matches(java.lang.reflect.Method, java.lang.Class&lt;?&gt;) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
        <annotation name='org.jetbrains.kannotator.runtime.annotations.Propagated'>
            <val name="value" val="{org.jetbrains.kannotator.controlFlow.builder.analysis.NullabilityKey.class}"/>
        </annotation>
    </item>
    <item name='org.springframework.aop.support.DelegatePerTargetObjectIntroductionInterceptor java.lang.Object invoke(org.aopalliance.intercept.MethodInvocation) 0'>
        <annotation name='org.jetbrains.annotations.NotNull'/>
    </item>
</root>
